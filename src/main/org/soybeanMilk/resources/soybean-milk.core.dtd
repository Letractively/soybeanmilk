<?xml version="1.0" encoding="UTF-8"?>
<!--根元素-->
<!ELEMENT soybean-milk (global-config?,includes?,resolvers?,executables)>

<!--全局配置-->
<!ELEMENT global-config (generic-converter)>

<!--
通用转换器配置

通过这里的通用转换器配置，你可以为框架添加自定义的辅助转换器或者完全替换框架默认的通用转换器，比如：
<generic-converter>
	<converter src="java.lang.String" target="java.util.Date" class="my.converter.DateConverter" />
</generic-converter>
将为框架添加字符串到日期的转换器（框架默认的将被替换掉）。
而：
<generic-converter class="my.converter.MyGenericConverter">
	...
	...
</generic-converter>
将完全替换框架默认的通用转换器。
当然，你的“my.converter.MyGenericConverter”类必须实现“org.soybeanMilk.core.bean.GenericConverter”接口。
-->
<!ELEMENT generic-converter (converter*)>

<!--
自定义的辅助转换器，它将被添加到通用转换器中以提供转换支持，后添加的将会替换掉先添加的
-->
<!ELEMENT converter EMPTY>

<!--
包含的模块配置文件，模块配置中应该仅包含resolvers和executables，其他配置都是无效的
-->
<!ELEMENT includes (file*)>
<!--
模块配置文件名，它可以是模糊的也可以是明确的
比如：
“my/cfg/*”			表示目录“my/cfg/”下面的所有XML文件（不包括子目录）
“my/cfg/my.xml”		表示单一的配置文件
-->
<!ELEMENT file (#PCDATA)>

<!--
解决对象配置

你可以在这里定义解决对象集，然后供之后的<invoke>配置使用，比如：
<resolvers>
	<resolver id="myResolver" class="my.resolver.TestResolver" />
</resolvers>
要注意的是，解决对象必须提供默认的无参构造方法。
-->
<!ELEMENT resolvers (resolver*)>
<!ELEMENT resolver EMPTY>

<!--
可执行对象配置

这里你即可以添加全局<invoke>，也可以添加全局<action>，不同的是<invoke>是原子可执行对象，即它不能包含子可执行对象；
而<action>则不同，它可以包含多个<invoke>对象，也可以引用其他已定义的全局<invoke>或者<action>。
下面是一个示例：
<executables>
	<invoke name="print" method="printStatic" resolver-class="my.util.Utils">
		<arg key="printObject" />
	</invoke>
	<action name="calculate">
		<invoke name="multiply" resolver="myResolver" result-key="printObject">
			<arg key="mulArg1" />
			<arg key="mulArg2" />
		</invoke>
		<ref name="print" />
	</action>
</executables>
如果你执行“print”调用，则是打印关键字为“printObject”的输入对象；
如果你执行“calculate”动作，则是先计算，然后打印结果。
-->
<!ELEMENT executables (invoke | action)*>

<!--
动作
它可以包含多个局部调用或者全局引用
-->
<!ELEMENT action (invoke | ref)*>
<!--
执行引用，将已定义的可执行对象添加到本次执行中。
注意，你不应该引用本身，这样会导致死循环。
-->
<!ELEMENT ref EMPTY>

<!--
调用配置
如果是全局调用，你应该配置其“name”属性，而在配置局部调用时，则不需要
-->
<!ELEMENT invoke (#PCDATA | arg)*>

<!--
参数配置
每个调用的参数配置必须与其执行的方法是一一对应的，也即是方法有几个参数，这里你就要为其配置几个参数。
你可以在标签内设置该参数的关键字，或者直接设置参数的值，语法与Java语法一致。
比如对于方法
int multiply(int a, int b);
你可以这样配置
<invoke method="multiply" ...>
	<arg>input_a</arg>
	<arg>5</arg>
</invoke>

需要要注意的是参数值的设置只支持基本类型和String类型，下面是一些设置示例：
<arg>my.argKey</arg>	设置参数的关键字为"my.argKey"
<arg>true</arg>			设置参数的值为true
<arg>3.5f</arg>			设置参数的值为3.5f
<arg>'c'</arg>			设置参数的值为字符'c'
<arg>"abcdef"</arg>		设置参数的值为字符串"abcdef"
<arg>null</arg>			设置参数的值为null
-->
<!ELEMENT arg (#PCDATA)>

<!--
自定义通用转换器完整类名，它的值需要能够被Class.forName("[class]").newInstance()正确使用
-->
<!ATTLIST generic-converter class CDATA #IMPLIED>

<!--
自定义转换器属性
src 它支持转换的源类型，它的值要能够被Class.forName("[class]")正确使用
target 它支持转换的目标类型，它的值要能够被Class.forName("[class]")正确使用
class 转换器类，它的值要能够被Class.forName("[class]").newInstance()正确使用
-->
<!ATTLIST converter src CDATA #REQUIRED>
<!ATTLIST converter target CDATA #REQUIRED>
<!ATTLIST converter class CDATA #REQUIRED>

<!--
解决对象配置属性
class 解决对象类名，它的值要能够被Class.forName("[class]").newInstance()正确使用
-->
<!ATTLIST resolver id ID #REQUIRED>
<!ATTLIST resolver class CDATA #REQUIRED>

<!--
动作的名称属性
执行器通过这个名称来查找动作对象并执行
-->
<!ATTLIST action name CDATA #REQUIRED>

<!--
执行引用名称，它可以引用在任何位置定义的全局可执行对象
-->
<!ATTLIST ref name CDATA #REQUIRED>

<!--
调用配置的名称属性
如果调用是全局的，那么它应该与动作一起是全局唯一的；如果是局部的，则不必如此
-->
<!ATTLIST invoke name CDATA #REQUIRED>

<!--
调用执行的方法名称
它要能够在之后配置的resolver-class或者resolver类中找到，默认与名称相同
-->
<!ATTLIST invoke method CDATA #IMPLIED>

<!--
调用的解决对象配置，配置解析器通过它来查找方法对象并确定参数类型
resolver-class 解决对象类名
resolver 之前定义的解决对象ID
如果方法是静态的，你可以仅指定“resolver-class”；
无论方法是否静态，你都可以指定“resolver”，不过“resolver-class”总是优先被配置解析器使用。
当然，如果方法是非静态的，执行的时候还是需要“resolver”的
-->
<!ATTLIST invoke resolver-class CDATA #IMPLIED>
<!ATTLIST invoke resolver CDATA #IMPLIED>

<!--
调用执行结果保存关键字属性，调用的方法执行结果将以此关键字保存到对象源中。
无论方法是否有返回结果，只要你定义了“result-key”，框架总会执行保存操作，只不过无返回结果的话是以null值保存的。
-->
<!ATTLIST invoke result-key CDATA #IMPLIED>